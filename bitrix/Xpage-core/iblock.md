---
sidebar_position: 4
---

# iblock.php

Этот файл — вспомогательный класс (хелпер) для работы с Инфоблоками в Битриксе. Его главная задача — избавить разработчика от написания громоздких запросов к базе данных для получения метаданных (ID, кодов, свойств).

Ключевая особенность этого класса — **агрессивное кэширование**. Данные кэшируются как на уровне статической переменной (внутри одного выполнения скрипта), так и в файловом кэше Битрикса на 8 лет (`$ttl`).



### 1. `getIblockIdByApiCode(string $apiCode)`
**Что делает:** Находит числовой `ID` инфоблока по его `API_CODE` (символьный код для API, задается в настройках инфоблока).

*   **Зачем это нужно:** В коде лучше не использовать жестко прописанные ID (например, `15`), так как на разных серверах (тест/прод) они могут отличаться. Использование API_CODE делает код переносимым.
*   **Пример:**
    ```php
    $id = \Xpage\Core\Iblock::getIblockIdByApiCode('catalog_products');
    // Вернет, например, 12
    ```

### 2. `getIblockCodeById` и `getIblockApiCodeById`
**Что делают:** Обратные методы. Позволяют получить обычный символьный код (`CODE`) или современный `API_CODE`, зная `ID` инфоблока.
*   Используют внутренний приватный метод `getIblockFieldById`, который универсально тянет любое поле из таблицы инфоблоков.

### 3. `getProperties(string $iblockCode)`
**Что делает:**  Возвращает массив всех свойств указанного инфоблока.


###  Как работает метод (алгоритм)

1.  **Поиск ID инфоблока:** Сначала он конвертирует ваш строковый `API_CODE` в числовой `ID` (используя `getIblockIdByApiCode`).
2.  **Запрос к БД:** Выполняет один запрос к таблице свойств (`PropertyTable`) и достает:
    *   `ID` — числовой идентификатор.
    *   `CODE` — символьный код (например, `BRAND`).
    *   `PROPERTY_TYPE` — тип (S - строка, N - число, L - список, E - привязка к элементу и т.д.).
    *   `MULTIPLE` — `Y/N` (множественное или нет).
3.  **Обработка списков (Enum):** Если свойство является **списком** (`TYPE_LIST`), метод делает дополнительный шаг — вызывает `getMapEnumPropertyValues`. Это позволяет получить соответствие «ID значения <-> Внешний код (XML_ID)».
4.  **Кэширование:** Весь результат сохраняется в кэш Битрикса. База данных не дергается при повторных заходах.

---

### Что возвращает метод (структура массива)

Метод возвращает ассоциативный массив, где **ключами являются символьные коды свойств**.

**Пример возвращаемого массива:**
```php
[
    'COLOR' => [
        'ID' => '15',
        'CODE' => 'COLOR',
        'PROPERTY_TYPE' => 'L', // Список
        'MULTIPLE' => 'N',
        'MAP_VALUES' => [       // Появляется только для списков
            'ID_TO_XMLID' => [
                '101' => 'RED',
                '102' => 'GREEN'
            ],
            'XMLID_TO_ID' => [
                'RED' => '101',
                'GREEN' => '102'
            ]
        ]
    ],
    'PRICE' => [
        'ID' => '16',
        'CODE' => 'PRICE',
        'PROPERTY_TYPE' => 'N', // Число
        'MULTIPLE' => 'N'
    ]
]
```

---

### Примеры использования

#### Пример А: Получение ID свойства для запроса
Часто в старых методах Битрикса или в некоторых фильтрах нужно передавать `PROPERTY_ID` вместо кода.

```php
use Xpage\Core\Iblock;

$allProps = Iblock::getProperties('catalog_api');

if (isset($allProps['BRAND'])) {
    $brandPropId = $allProps['BRAND']['ID'];
    
    // Используем в фильтре
    $res = \CIBlockElement::GetList([], [
        'IBLOCK_ID' => 10,
        'PROPERTY_'.$brandPropId => 55 // Фильтр по ID значения
    ]);
}
```

#### Пример Б: Работа со свойствами типа «Список» (самый полезный кейс)
Представьте, что у вас есть форма на сайте, и вы хотите программно создать элемент. У вас есть значение "Зеленый" (его XML_ID = `GREEN`), но Битриксу для сохранения в БД нужно передать **числовой ID этого значения**.

```php
use Xpage\Core\Iblock;

$props = Iblock::getProperties('cars');

// Нам нужно узнать ID значения "BMW" для свойства "MARK"
$markXmlId = 'BMW';
$markValueId = $props['MARK']['MAP_VALUES']['XMLID_TO_ID'][$markXmlId] ?? null;

if ($markValueId) {
    $el = new \CIBlockElement;
    $el->Add([
        'IBLOCK_ID' => 12,
        'NAME' => 'Новая машина',
        'PROPERTY_VALUES' => [
            'MARK' => $markValueId // Передаем найденное число 123
        ]
    ]);
}
```

#### Пример В: Проверка типа или множественности
Если вы пишете универсальный обработчик данных, вам нужно знать, как обрабатывать значение: как строку или как массив.

```php
$props = \Xpage\Core\Iblock::getProperties('feedback');

$myProp = $props['DOCUMENTS'];

if ($myProp['MULTIPLE'] === 'Y') {
    echo "Это свойство может содержать много файлов";
}

if ($myProp['PROPERTY_TYPE'] === 'F') {
    echo "Это свойство типа 'Файл'";
}
```

---

### Почему это круто?

1.  **Защита от «Магических чисел»:** Вам больше не нужно писать в коде `$PROP_ID = 148;`. Вы пишете `$props['MY_CODE']['ID']`.
2.  **Экономия запросов:** Если на странице 5 разных блоков кода обращаются к свойствам одного инфоблока, `getProperties` выполнит запрос к базе только **один раз**, а в остальные разы возьмет данные из быстрой оперативной памяти (static cache).
3.  **Удобная работа с XML_ID:** В Битриксе стандартно очень неудобно получать ID значения списка по его коду. Этот метод решает проблему через вложенный массив `MAP_VALUES`.

    1. Получает ID инфоблока.
    2. Достает все свойства (ID, код, тип, множественность).
    3. **Важная фишка:** Если свойство типа «Список» (`L`), метод автоматически подтягивает все варианты значений этого списка (см. следующий метод).
*   **Результат:** Вы получаете готовую карту (map) свойств, где ключами являются их символьные коды.

### 4. `getMapEnumPropertyValues(int $propertyId)`
**Что делает:** Создает «карту» (сопоставление) для свойств типа «Список».
*   **Зачем это нужно:** В Битриксе у элементов списка есть внутренний `ID` (число) и `XML_ID` (внешний код). Часто из внешних систем (1С, ERP) приходит `XML_ID`, а Битриксу для фильтрации или записи нужен числовой `ID`.
*   **Результат:** Возвращает массив с двумя словарями:
    *   `ID_TO_XMLID`: позволяет узнать код, зная ID.
    *   `XMLID_TO_ID`: позволяет узнать ID, зная код.
*   **Пример:**
    ```php
    $map = \Xpage\Core\Iblock::getMapEnumPropertyValues(45);
    $realId = $map['XMLID_TO_ID']['RED_COLOR']; // Вернет, например, 105
    ```

---
### Пример комплексного использования:

```php
use Xpage\Core\Iblock;

// Получаем все свойства инфоблока "Каталог"
$props = Iblock::getProperties('catalog');

// Проверяем, существует ли свойство COLOR и какой у него ID
if (isset($props['COLOR'])) {
    $propId = $props['COLOR']['ID'];
    
    // Если это список, можем быстро найти ID значения "Зеленый" по его XML_ID
    $greenId = $props['COLOR']['MAP_VALUES']['XMLID_TO_ID']['GREEN'];
}
```

