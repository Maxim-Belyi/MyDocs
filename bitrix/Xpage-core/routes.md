---
sidebar_position: 13
---

# `include/routes.php`

#### Файл: `include/routes.php`
**Назначение**: Карта маршрутов проекта. Связывает URL-адреса с конкретными PHP-обработчиками. Является входной точкой для всех внутренних API-запросов и систем социальной авторизации.

**Зависимости**:
*   Ядро: `Bitrix\Main\Routing\RoutingConfigurator`, `Bitrix\Main\Context`.
*   Контроллеры: `Xpage\Core\Controller\...` (Captcha, Authentication).
*   Сервисы авторизации: `Xpage\Core\Service\Authentication\...` (VkId, YaId, SberId).

---

## 1. Внутреннее API (Внутренние сервисы)
Большинство роутов ведут напрямую в методы контроллеров. Битрикс автоматически вызывает метод `названиеAction` в указанном классе.

*   **Капча (ReCaptcha / SmartCaptcha)**:
    *   `POST /api-internal/recaptcha/validate`: Проверка токена.
    *   `GET /api-internal/recaptcha/key`: Получение публичного ключа.
*   **Стандартная авторизация**:
    *   `POST /api-internal/user/register`: Регистрация.
    *   `POST /api-internal/user/login`: Вход.
    *   `POST /api-internal/user/logout`: Выход.
    *   `POST /api-internal/user/password/recovery`: Сброс пароля.

## 2. Социальная авторизация (OAuth 2.0)
Для каждого сервиса (VK, Yandex, Sber) реализовано два типа маршрутов:

1.  **POST `.../link`**: Ведет в контроллер. Используется фронтендом для получения ссылки, на которую нужно перенаправить пользователя для входа.
2.  **GET `.../` (Callback)**: Анонимная функция (замыкание). Это адрес, на который сервис (например, Сбер) возвращает пользователя после успешного ввода логина/пароля.
    *   **Логика**: Извлекает `code` и `state` из запроса.
    *   **Безопасность**: Проверяет `state === bitrix_sessid()` для защиты от CSRF-атак.
    *   **Действие**: Создает объект сервиса (`new SberId($code)`) и вызывает `Authorize()`.

---

## Примеры использования

### Пример 1: Обращение к API из JS (Фронт)
Когда пользователь нажимает "Войти", фронт делает запрос к роуту, описанному в этом файле:
```javascript
// Запрос к роуту /api-internal/user/login
fetch('/api-internal/user/login', {
    method: 'POST',
    body: JSON.stringify({ login: '...', password: '...' })
});
```

### Пример 2: Использование именованного роута (Бэкенд)
В коде можно получить URL роута по его имени (заданному через `->name()`):
```php
use Bitrix\Main\Application;

$router = Application::getInstance()->getRouter();
// Получим "/api-internal/user/sber-id"
$url = $router->route('xpage_core_auth_sber_id'); 
```

---

## Особенности реализации
*   **Слеши в URL**: Для каждого метода прописано два варианта — со слешем на конце и без него (например, `/validate/` и `/validate`). Это гарантирует работу API при любых настройках фронтенда.
*   **Инкапсуляция**: Вся сложная логика авторизации через соцсети вынесена в соответствующие сервисы, роуты лишь принимают входящие данные (`code`) и передают их дальше.
*   **Контроль сессии**: В callback-роутах обязательно проверяется `bitrix_sessid()`, чтобы гарантировать, что ответ от соцсети пришел в рамках той же сессии, в которой он был инициирован.

---
